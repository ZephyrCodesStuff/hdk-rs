//! Shared crypto utilities for archive formats (BAR/SHARC helpers)

/// DEFAULT key used to encrypt BAR file bodies.
pub const DEFAULT_KEY: [u8; 32] = [
    0x80, 0x6D, 0x79, 0x16, 0x23, 0x42, 0xA1, 0x0E, 0x8F, 0x78, 0x14, 0xD4, 0xF9, 0x94, 0xA2, 0xD1,
    0x74, 0x13, 0xFC, 0xA8, 0xF6, 0xE0, 0xB8, 0xA4, 0xED, 0xB9, 0xDC, 0x32, 0x7F, 0x8B, 0xA7, 0x11,
];

/// Signature key used to encrypt BAR file head/signature area.
pub const SIGNATURE_KEY: [u8; 32] = [
    0xEF, 0x8C, 0x7D, 0xE8, 0xE5, 0xD5, 0xD6, 0x1D, 0x6A, 0xAA, 0x5A, 0xCA, 0xF7, 0xC1, 0x6F, 0xC4,
    0x5A, 0xFC, 0x59, 0xE4, 0x8F, 0xE6, 0xC5, 0x93, 0x7E, 0xBD, 0xFF, 0xC1, 0xE3, 0x99, 0x9E, 0x62,
];

/// Forge an 8-byte IV used by BAR encrypted entries.
///
/// The algorithm matches the reader behaviour used to parse existing BAR files
/// and encodes uncompressed size, compressed size, offset and timestamp into
/// a single 64-bit value that is then returned in big-endian byte order.
#[must_use] 
pub const fn forge_iv(
    num_files: u64,
    uncomp_size: u64,
    comp_size: u64,
    offset: u64,
    timestamp: i32,
) -> [u8; 8] {
    let extended_timestamp = 0xFFFFFFFF00000000u64 | (timestamp as u64);
    let val = (uncomp_size << 0x30)
        | ((comp_size & 0xFFFF) << 0x20)
        | (((offset + 20 + (num_files * 16)) & 0x3FFFC) << 0xE)
        | (extended_timestamp & 0xFFFF);
    val.to_be_bytes()
}
